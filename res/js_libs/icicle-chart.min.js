window.addEventListener("keydown", function (event) {
    if (event.key === "Escape") {
        d3.selectAll("rect").style("stroke", "#000").style("stroke-width", 0.2);
        selectedClusterContainer = [];
        d3.selectAll(".magnifying-icon").remove();
        if (!isDebug) {
            passSelectionToQt("");
        } else {
            console.log("Selected clusters: " + selectedClusterContainer);
        }
    }
});

function calculateBrightness(color) {
    const rgb = d3.color(color).rgb();
    // Using the luminance formula
    return (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
}

function getTextColorBasedOnBackgroundColor(color) {
    return calculateBrightness(color) > 0.5 ? "#000" : "#fff";
}

function VisCreate() {
    console.log("VisCreate");
    d3.select("svg").remove();
    svg = d3.select("#my_dataviz");
    svg.selectAll("*").remove();
    d3.selectAll("#rectLabel").remove();
    width = window.innerWidth - margin.left - margin.right;
    height = window.innerHeight - margin.top - margin.bottom;

    x = d3.scaleLinear().range([0, width]);
    y = d3.scaleLinear().range([0, height]);

    partition = d3.partition().size([width, height]).padding(0).round(true);

    svg = d3
        .select("#my_dataviz")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    rect = svg.selectAll("rect");

    var dataForChart = data;

    dataForChart = d3
        .hierarchy(dataForChart, function (d) {
            return d.children;
        })
        .sum(function (d) {
            return d.value;
        })
        .sort(function (a, b) {
            return b.value - a.value;
        });

    partition(dataForChart);

    rect = rect
        .data(dataForChart.descendants())
        .enter()
        .append("rect")
        .attr("id", function (d) {
            var returnValue =
                "id" +
                d.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                "_level" +
                d.depth;
            return returnValue;
        })
        .attr("x", function (d) {
            return d.x0;
        })
        .attr("cursor", "pointer")
        .attr("y", function (d) {
            return d.y0;
        })
        .attr("width", function (d) {
            return d.x1 - d.x0;
        })
        .attr("height", function (d) {
            return d.y1 - d.y0;
        })
        .attr("fill", function (d) {
            return d.data.color;
        })
        .attr("stroke", function (d) {
            return "#000";
        })
        .attr("stroke-width", 0.2)
        .on("click", clicked)
        .on("contextmenu", rightClicked);

    rect.append("title").text(function (d) {
        var returnText =
            "Cluster name: " + d.data.name + "\nCell count: " + d.value;
        return returnText;
    });

    // Add text after rectangles
    svg
        .selectAll(null)
        .data(dataForChart.descendants())
        .enter()
        .filter(function (d) {
            return d.data.name !== "All";
        })
        .append("text")
        .attr("id", "rectLabel")
        .attr("x", function (d) {
            return d.x0 + (d.x1 - d.x0) / 2;
        })
        .attr("y", function (d) {
            return d.y0 + (d.y1 - d.y0) / 2;
        })
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("fill", function (d) {
            return getTextColorBasedOnBackgroundColor(d.data.color);
        })
        .text(function (d) {
            var rectWidth = d.x1 - d.x0;
            var rectHeight = d.y1 - d.y0;
            var estimatedTextWidth = d.data.name.length * 10; // Adjust based on your font size
            var estimatedTextHeight = 14; // Assuming a fixed text height, adjust as needed

            if (rectWidth > estimatedTextWidth && rectHeight > estimatedTextHeight) {
                return d.data.name; // Width and height are sufficient, show text normally
            } else if (
                rectHeight > estimatedTextWidth &&
                rectWidth > estimatedTextHeight
            ) {
                return d.data.name; // Height is sufficient for vertical text, and width is sufficient for text height
            } else {
                return ""; // Neither condition is met, do not show text
            }
        })
        .attr("transform", function (d) {
            var rectWidth = d.x1 - d.x0;
            var rectHeight = d.y1 - d.y0;
            var estimatedTextWidth = d.data.name.length * 10; // Adjust based on your font size
            var estimatedTextHeight = 14; // Assuming a fixed text height, adjust as needed
            var rotation = 0;
            var xMid = d.x0 + rectWidth / 2;
            var yMid = d.y0 + rectHeight / 2;

            if (rectHeight > estimatedTextWidth && rectWidth > estimatedTextHeight) {
                rotation = 270;
            }

            return `rotate(${rotation},${xMid},${yMid})`;
        })
        .style("pointer-events", "none");

    function clicked(d) {
        if (d3.event.ctrlKey) {
            d3.selectAll("#rectLabel").remove();

            x.domain([d.x0, d.x1]);
            y.domain([d.y0, height]).range([d.depth ? 20 : 0, height]);

            rect
                .transition()
                .duration(200)
                .ease(d3.easePolyIn.exponent(3))
                .attr("x", function (d) {
                    return x(d.x0);
                })
                .attr("y", function (d) {
                    return y(d.y0);
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0);
                })
                .attr("height", function (d) {
                    return y(d.y1) - y(d.y0);
                });

            // Add text after rectangles
            svg
                .selectAll(null)
                .data(dataForChart.descendants())
                .enter()
                .filter(function (d) {
                    return d.data.name !== "All";
                })
                .append("text")
                .attr("id", "rectLabel")
                .attr("x", function (d) {
                    return x(d.x0 + (d.x1 - d.x0) / 2);
                })
                .attr("y", function (d) {
                    return y(d.y0 + (d.y1 - d.y0) / 2);
                })
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "middle")
                .attr("fill", function (d) {
                    return getTextColorBasedOnBackgroundColor(d.data.color);
                })
                .text(function (d) {
                    var rectWidth = x(d.x1) - x(d.x0);
                    var rectHeight = y(d.y1) - y(d.y0);
                    var estimatedTextWidth = d.data.name.length * 10;
                    var estimatedTextHeight = 14;

                    if (
                        rectWidth > estimatedTextWidth &&
                        rectHeight > estimatedTextHeight
                    ) {
                        return d.data.name;
                    } else if (
                        rectHeight > estimatedTextWidth &&
                        rectWidth > estimatedTextHeight
                    ) {
                        return d.data.name;
                    } else {
                        return "";
                    }
                })
                .attr("transform", function (d) {
                    var rectWidth = x(d.x1) - x(d.x0);
                    var rectHeight = y(d.y1) - y(d.y0);
                    var estimatedTextWidth = d.data.name.length * 10;
                    var estimatedTextHeight = 14;
                    var rotation = 0;
                    var xMid = x(d.x0) + rectWidth / 2;
                    var yMid = y(d.y0) + rectHeight / 2;

                    if (
                        rectHeight > estimatedTextWidth &&
                        rectWidth > estimatedTextHeight
                    ) {
                        rotation = 270;
                    }

                    return `rotate(${rotation},${xMid},${yMid})`;
                })
                .style("pointer-events", "none");
        } else {
            var maxDepth = d3.max(dataForChart.descendants(), function (d) {
                return d.depth;
            });

            if (d3.event.shiftKey) {
                d.descendants().forEach(function (descendant) {
                    var validId =
                        "id" +
                        descendant.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                        "_level" +
                        descendant.depth;

                    if (maxDepth === descendant.depth) {
                        if (selectedClusterContainer.indexOf(descendant.data.name) === -1) {
                            selectedClusterContainer.push(descendant.data.name);
                        }
                        if (!isDebug) {
                            passSelectionToQt(selectedClusterContainer);
                        } else {
                            console.log("Selected clusters: " + selectedClusterContainer);
                        }
                    }
                    d3.select("#" + validId)
                        .style("stroke", "#00A3EE")
                        .style("stroke-width", 4);
                });
            } else {
                d3.selectAll("rect").style("stroke", "#000").style("stroke-width", 0.2);

                selectedClusterContainer = [];
                d.descendants().forEach(function (descendant) {
                    var validId =
                        "id" +
                        descendant.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                        "_level" +
                        descendant.depth;

                    if (maxDepth === descendant.depth) {
                        if (selectedClusterContainer.indexOf(descendant.data.name) === -1) {
                            selectedClusterContainer.push(descendant.data.name);
                        }
                    }
                    d3.select("#" + validId)
                        .style("stroke", "#00A3EE")
                        .style("stroke-width", 4);
                });
                d3.selectAll(".magnifying-icon").remove();
                if (!isDebug) {
                    passSelectionToQt(selectedClusterContainer);
                } else {
                    console.log("Selected clusters: " + selectedClusterContainer);
                }
            }
        }
    }
    function rightClicked(event) {
        // Disable right-click at level 0
        if (event.depth === 0) {
            return;
        }

        const clusterName = event.data.name;
        const clusterLevel = event.depth;
        const clusterNameAndLevel = clusterName + " @%$,$%@ " + clusterLevel;

        // Reset the stroke of the previously clicked rectLabel
        if (previousClicked) {
            d3.select(previousClicked).style("stroke", "none");
        }

        // Reset the stroke of all rects
        d3.selectAll("rect").style("stroke", "#000").style("stroke-width", 0.2);

        const validId = `id${clusterName
            .replace(/\//g, "_")
            .replace(/\s/g, "-")}_level${clusterLevel}`;

        // Remove any existing icons
        d3.selectAll(".magnifying-icon").remove();

        const rectWidth = event.x1 - event.x0;
        const rectHeight = event.y1 - event.y0;
        const centerX = event.x0 + rectWidth / 2;
        const centerY = event.y0 + rectHeight / 2;

        const label = d3.select(`#${validId} text`);
        const hasLabel = !label.empty();
        const labelOrientation = hasLabel ? label.attr("transform") : null;

        let iconX = centerX;
        let iconY = centerY;

        if (hasLabel && labelOrientation && labelOrientation.includes("rotate")) {
            iconX = event.x1 + 10;
            iconY = event.y0 + rectHeight / 2;
        }

        svg
            .append("text")
            .attr("class", "magnifying-icon")
            .attr("x", iconX)
            .attr("y", iconY)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("font-size", "12px")
            .text("🔍");

        previousClicked = d3.select(`#${validId}`).node();

        if (!isDebug) {
            passRightClickToQt(clusterNameAndLevel);
        } else {
            console.log(clusterNameAndLevel);
        }
    }
    let bottomHierarchyNames = dataForChart
        .descendants()
        .filter((node) => !node.children)
        .sort((a, b) => a.x0 - b.x0)
        .map((node) => node.data.name);

    if (!isDebug) {
        passClusterOrderToQT(bottomHierarchyNames);
    } else {
        console.log("Bottom hierarchy names: " + bottomHierarchyNames);
    }
}
