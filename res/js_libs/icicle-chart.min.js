window.addEventListener('keydown', function (event) {
    if (event.key === 'Escape') {

        /*if (event.ctrlKey) 
            {
            x.domain([0, width]);
            y.domain([0, height]);

            rect
                .transition()
                .duration(200)
                .ease(d3.easePolyIn.exponent(3))
                .attr("x", function (d) {
                    return x(d.x0);
                })
                .attr("y", function (d) {
                    return y(d.y0);
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0);
                })
                .attr("height", function (d) {
                    return y(d.y1) - y(d.y0);
                });
        }
        else */
        {
            d3.selectAll('rect')
                .style('stroke', '#000')
                .style('stroke-width', 0.2);
            selectedClusterContainer = [];
            passSelectionToQt("");
        }




    }
});

function VisCreate() {
    d3.select("svg").remove();
    svg = d3.select("#my_dataviz");
    svg.selectAll("*").remove();

    width = window.innerWidth - margin.left - margin.right;
    height = window.innerHeight - margin.top - margin.bottom;

    x = d3.scaleLinear().range([0, width]);

    y = d3.scaleLinear().range([0, height]);

    partition = d3.partition().size([width, height]).padding(0).round(true);

    svg = d3
        .select("#my_dataviz")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    rect = svg.selectAll("rect");

    var dataForChart = data;

    dataForChart = d3
        .hierarchy(dataForChart, function (d) {
            return d.children;
        })
        .sum(function (d) {
            return d.value;
        })
        .sort(function (a, b) {
            return b.value - a.value;
        });
    partition(dataForChart);

    rect = rect
        .data(dataForChart.descendants())
        .enter()
        .append("rect")
        .attr("id", function (d) {
            var returnValue = "id" + d.data.name.replace(/\//g, '_').replace(/\s/g, '-') + "_level" + d.depth;
            return returnValue;

        })

        .attr("x", function (d) {
            return d.x0;
        })
        .attr("cursor", "pointer")
        .attr("y", function (d) {
            return d.y0;
        })
        .attr("width", function (d) {
            return d.x1 - d.x0;
        })
        .attr("height", function (d) {
            return d.y1 - d.y0;
        })
        .attr("fill", function (d) {
            return d.data.color;
        })
        .attr("stroke", function (d) {
            return "#000";
        })
        .attr("stroke-width", 0.2)
        .on("click", clicked);

    rect
        .append("title") // Append title element to each rectangle
        .text(function (d) {
            var returnText = "";
            returnText = "Cluster name: " + d.data.name + "\n" + "Cell count: " + d.value;
            return returnText;//d.data.name + ": " + d.value; // Set the text of the title to the name and value of the data
        });

    function clicked(d) {
        //d3.event.shiftKey
        if (d3.event.ctrlKey) {
            x.domain([d.x0, d.x1]);
            y.domain([d.y0, height]).range([d.depth ? 20 : 0, height]);

            rect
                .transition()
                .duration(200)
                .ease(d3.easePolyIn.exponent(3))
                .attr("x", function (d) {
                    return x(d.x0);
                })
                .attr("y", function (d) {
                    return y(d.y0);
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0);
                })
                .attr("height", function (d) {
                    return y(d.y1) - y(d.y0);
                });
        }
        else {
            var maxDepth = d3.max(dataForChart.descendants(), function (d) { return d.depth; });
            if (d3.event.shiftKey) {
                d.descendants().forEach(function (descendant) {

                    var validId = "id" + descendant.data.name.replace(/\//g, '_').replace(/\s/g, '-') + "_level" + descendant.depth;

                    if (maxDepth == descendant.depth) {

                        //selectedClusterContainer
                        //if descendant.data.name is not in selectedClusterContainer, add it else do nothing
                        if (selectedClusterContainer.indexOf(descendant.data.name) == -1) {

                            selectedClusterContainer.push(descendant.data.name);
                        }
                        passSelectionToQt(selectedClusterContainer);
                    }
                    d3.select("#" + validId)
                        .style('stroke', '#00A3EE') // change 'red' to the color you want
                        .style('stroke-width', 4); // change '2' to the width you want
                });
            }
            else {
                d3.selectAll('rect')
                    .style('stroke', '#000')
                    .style('stroke-width', 0.2);
                //get the max depth of the tree

                selectedClusterContainer = [];
                // add a stroke with a different color to the clicked rectangle and all its children
                d.descendants().forEach(function (descendant) {

                    var validId = "id" + descendant.data.name.replace(/\//g, '_').replace(/\s/g, '-') + "_level" + descendant.depth;

                    if (maxDepth == descendant.depth) {

                        //selectedClusterContainer
                        //if descendant.data.name is not in selectedClusterContainer, add it else do nothing
                        if (selectedClusterContainer.indexOf(descendant.data.name) == -1) {

                            selectedClusterContainer.push(descendant.data.name);
                        }

                    }
                    d3.select("#" + validId)
                        .style('stroke', '#00A3EE') // change 'red' to the color you want
                        .style('stroke-width', 4); // change '2' to the width you want
                });
                passSelectionToQt(selectedClusterContainer);
            }



        }

    }

    let bottomHierarchyNames = dataForChart
        .descendants()
        .filter((node) => !node.children) // Filter to get only leaf nodes
        .sort((a, b) => a.x0 - b.x0) // Sort nodes by their x0 value
        .map((node) => node.data.name); // Extract the name property

    passClusterOrderToQT(bottomHierarchyNames);

}


