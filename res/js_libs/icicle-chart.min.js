window.addEventListener("keydown", function (event) {
    if (event.key === "Escape") {
        d3.selectAll("rect").style("stroke", "#000").style("stroke-width", 0.2);
        selectedClusterContainer = [];
        if (!isDebug) {
            passSelectionToQt("");
        }
    }
});

function calculateBrightness(color) {
    const rgb = d3.color(color).rgb();
    // Using the luminance formula
    return (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
}

function getTextColorBasedOnBackgroundColor(color) {
    return calculateBrightness(color) > 0.5 ? "#000" : "#fff";
}

function VisCreate() {
    d3.select("svg").remove();
    svg = d3.select("#my_dataviz");
    svg.selectAll("*").remove();
    d3.selectAll("#rectLabel").remove();
    width = window.innerWidth - margin.left - margin.right;
    height = window.innerHeight - margin.top - margin.bottom;

    x = d3.scaleLinear().range([0, width]);
    y = d3.scaleLinear().range([0, height]);

    partition = d3.partition().size([width, height]).padding(0).round(true);

    svg = d3
        .select("#my_dataviz")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    rect = svg.selectAll("rect");

    var dataForChart = data;

    dataForChart = d3
        .hierarchy(dataForChart, function (d) {
            return d.children;
        })
        .sum(function (d) {
            return d.value;
        })
        .sort(function (a, b) {
            return b.value - a.value;
        });

    partition(dataForChart);

    rect = rect
        .data(dataForChart.descendants())
        .enter()
        .append("rect")
        .attr("id", function (d) {
            var returnValue =
                "id" +
                d.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                "_level" +
                d.depth;
            return returnValue;
        })
        .attr("x", function (d) {
            return d.x0;
        })
        .attr("cursor", "pointer")
        .attr("y", function (d) {
            return d.y0;
        })
        .attr("width", function (d) {
            return d.x1 - d.x0;
        })
        .attr("height", function (d) {
            return d.y1 - d.y0;
        })
        .attr("fill", function (d) {
            return d.data.color;
        })
        .attr("stroke", function (d) {
            return "#000";
        })
        .attr("stroke-width", 0.2)
        .on("click", clicked);

    rect.append("title").text(function (d) {
        var returnstring = d.data.name.replace(/_/g, " ");
        var returnText =
            "Cluster name: " + returnstring + "\nCell count: " + d.value;
        return returnText;
    });

    // Add text after rectangles
    svg
        .selectAll(null)
        .data(dataForChart.descendants())
        .enter()
        .filter(function (d) {
            return d.data.name !== "All";
        })
        .append("text")
        .attr("id", "rectLabel")
        .attr("x", function (d) {
            return d.x0 + (d.x1 - d.x0) / 2;
        })
        .attr("y", function (d) {
            return d.y0 + (d.y1 - d.y0) / 2;
        })
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("fill", function (d) {
            return getTextColorBasedOnBackgroundColor(d.data.color);
        })
        .text(function (d) {
            var rectWidth = d.x1 - d.x0;
            var rectHeight = d.y1 - d.y0;
            var estimatedTextWidth = d.data.name.length * 10; // Adjust based on your font size
            var estimatedTextHeight = 14; // Assuming a fixed text height, adjust as needed
            var returnstring = d.data.name.replace(/_/g, " ");
            if (rectWidth > estimatedTextWidth && rectHeight > estimatedTextHeight) {
                //replace underscores with spaces
                
                return returnstring; // Width and height are sufficient, show text normally
            } else if (
                rectHeight > estimatedTextWidth &&
                rectWidth > estimatedTextHeight
            ) {
                return returnstring; // Height is sufficient for vertical text, and width is sufficient for text height
            } else {
                return ""; // Neither condition is met, do not show text
            }
        })
        .attr("transform", function (d) {
            var rectWidth = d.x1 - d.x0;
            var rectHeight = d.y1 - d.y0;
            var estimatedTextWidth = d.data.name.length * 10; // Adjust based on your font size
            var estimatedTextHeight = 14; // Assuming a fixed text height, adjust as needed
            var rotation = 0;
            var xMid = d.x0 + rectWidth / 2;
            var yMid = d.y0 + rectHeight / 2;

            if (rectHeight > estimatedTextWidth && rectWidth > estimatedTextHeight) {
                rotation = 270;
            }

            return `rotate(${rotation},${xMid},${yMid})`;
        })
        .style("pointer-events", "none");

    function clicked(d) {
        let levelOneNames = new Set(); // New container for level 1 names

        function getLevelOneAncestor(node) {
            while (node.depth > 1) {
                node = node.parent;
            }
            return node.data.name;
        }

        if (d3.event.ctrlKey) {
            d3.selectAll("#rectLabel").remove();

            x.domain([d.x0, d.x1]);
            y.domain([d.y0, height]).range([d.depth ? 20 : 0, height]);

            rect
                .transition()
                .duration(200)
                .ease(d3.easePolyIn.exponent(3))
                .attr("x", function (d) {
                    return x(d.x0);
                })
                .attr("y", function (d) {
                    return y(d.y0);
                })
                .attr("width", function (d) {
                    return x(d.x1) - x(d.x0);
                })
                .attr("height", function (d) {
                    return y(d.y1) - y(d.y0);
                });

            // Add text after rectangles
            svg
                .selectAll(null)
                .data(dataForChart.descendants())
                .enter()
                .filter(function (d) {
                    return d.data.name !== "All";
                })
                .append("text")
                .attr("id", "rectLabel")
                .attr("x", function (d) {
                    return x(d.x0 + (d.x1 - d.x0) / 2);
                })
                .attr("y", function (d) {
                    return y(d.y0 + (d.y1 - d.y0) / 2);
                })
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "middle")
                .attr("fill", function (d) {
                    return getTextColorBasedOnBackgroundColor(d.data.color);
                })
                .text(function (d) {
                    var rectWidth = x(d.x1) - x(d.x0);
                    var rectHeight = y(d.y1) - y(d.y0);
                    var estimatedTextWidth = d.data.name.length * 10;
                    var estimatedTextHeight = 14;

                    if (
                        rectWidth > estimatedTextWidth &&
                        rectHeight > estimatedTextHeight
                    ) {
                        return d.data.name;
                    } else if (
                        rectHeight > estimatedTextWidth &&
                        rectWidth > estimatedTextHeight
                    ) {
                        return d.data.name;
                    } else {
                        return "";
                    }
                })
                .attr("transform", function (d) {
                    var rectWidth = x(d.x1) - x(d.x0);
                    var rectHeight = y(d.y1) - y(d.y0);
                    var estimatedTextWidth = d.data.name.length * 10;
                    var estimatedTextHeight = 14;
                    var rotation = 0;
                    var xMid = x(d.x0) + rectWidth / 2;
                    var yMid = y(d.y0) + rectHeight / 2;

                    if (
                        rectHeight > estimatedTextWidth &&
                        rectWidth > estimatedTextHeight
                    ) {
                        rotation = 270;
                    }

                    return `rotate(${rotation},${xMid},${yMid})`;
                })
                .style("pointer-events", "none");
        } else {
            var maxDepth = d3.max(dataForChart.descendants(), function (d) {
                return d.depth;
            });

            if (d3.event.shiftKey) {
                d.descendants().forEach(function (descendant) {
                    var validId =
                        "id" +
                        descendant.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                        "_level" +
                        descendant.depth;

                    if (maxDepth === descendant.depth) {
                        if (selectedClusterContainer.indexOf(descendant.data.name) === -1) {
                            selectedClusterContainer.push(descendant.data.name);
                        }
                        let concatenatedString =
                            selectedClusterContainer.join(" @%$,$%@ ") +
                            " $topsplit$ " +
                            Array.from(selectedLevelOneNames).join(" @%$,$%@ ");
                        if (!isDebug) {
                            passSelectionToQt(concatenatedString);
                        } else {
                            console.log(concatenatedString);
                        }
                    }
                    d3.select("#" + validId)
                        .style("stroke", "#00A3EE")
                        .style("stroke-width", 4);

                    // Store level 1 names
                    if (descendant.depth === 1) {
                        selectedLevelOneNames.add(descendant.data.name);
                    } else {
                        selectedLevelOneNames.add(getLevelOneAncestor(descendant));
                    }
                });
            } else {
                d3.selectAll("rect").style("stroke", "#000").style("stroke-width", 0.2);

                selectedClusterContainer = [];
                selectedLevelOneNames = new Set();
                d.descendants().forEach(function (descendant) {
                    var validId =
                        "id" +
                        descendant.data.name.replace(/\//g, "_").replace(/\s/g, "-") +
                        "_level" +
                        descendant.depth;

                    if (maxDepth === descendant.depth) {
                        if (selectedClusterContainer.indexOf(descendant.data.name) === -1) {
                            selectedClusterContainer.push(descendant.data.name);
                        }
                    }
                    d3.select("#" + validId)
                        .style("stroke", "#00A3EE")
                        .style("stroke-width", 4);

                    // Store level 1 names
                    if (descendant.depth === 1) {
                        selectedLevelOneNames.add(descendant.data.name);
                    } else {
                        selectedLevelOneNames.add(getLevelOneAncestor(descendant));
                    }
                });
                let concatenatedString =
                    selectedClusterContainer.join(" @%$,$%@ ") +
                    " $topsplit$ " +
                    Array.from(selectedLevelOneNames).join(" @%$,$%@ ");
                if (!isDebug) {
                    passSelectionToQt(concatenatedString);
                } else {
                    console.log(concatenatedString);
                }
            }
        }

        // Update global set with the new level 1 names
        //levelOneNames.forEach((name) => globalLevelOneNames.add(name));

        //console.log("Level 1 Names: ", Array.from(globalLevelOneNames)); // Log the level 1 names
    }

    let bottomHierarchyNames = dataForChart
        .descendants()
        .filter((node) => !node.children)
        .sort((a, b) => a.x0 - b.x0)
        .map((node) => node.data.name);

    if (!isDebug) {
        passClusterOrderToQT(bottomHierarchyNames);
    }
}
